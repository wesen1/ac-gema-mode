//
// @author wesen
// @copyright 2018 wesen <wesen-ac@web.de>
//

//
// Count down module for ac-gema-mode
//
// Handles printing of count downs
// There can only be one active count down at a time
//
// Requires:
//   * scripts/ac-gema-mode/time-parser.cfg
//   * scripts/ac-gema-mode/time-target.cfg
//
check2init countDownModeActive 0;   // De-/activates countdown mode
check2init countDownTime 0;         // Stores the initial time of the current count down in milliseconds
check2init lastCountDownChange 0;   // Stores the milliseconds since game start of the last countdown change

persistidents 0;

//
// Sets the count down mode state.
//
// @param int $arg1 The new count down state
//                  0: Deactivates the count down mode
//                  1: Activates the count down mode
//
const setCountDownModeActive [

  if (&& (! (isTimeTargetModeActive)) $arg1) [
    printGemaNotification (concat (c $colorError) "Can not activate count down: Time target mode is not activated.");
  ][
    countDownModeActive = $arg1;
  ]

]

//
// Returns whether the countdown mode is currently active.
//
// @return int 0: Countdown mode is not active
//             1: Countdown mode is active
//
const isCountDownModeActive [
  return $countDownModeActive;
]

//
// Sets the count down time in milliseconds.
// Set the time to 0 to disable the count down.
//
// @param int $arg1 The new count down time in milliseconds
//
const setCountDownTime [
  countDownTime = $arg1;
]

//
// Returns whether there is a countdown currently running.
//
// @return int 0: There is no countdown currently running
//             1: There is a countdown currently running
//
const isCountDownActive [

  if (> $countDownTime 0) [
    return 1;
  ][
    return 0;
  ]

]


//
// Shows a count down in seconds in the console.
//
// @param int $arg1 The length of the count down in milliseconds
// @param String $arg2 The message to show when the count down is finished
//
const initializeCountDown [

  lastCountDownChange = 0;
  countDownTime = $arg1;
  countDownFinishedMessage = $arg2;
  parsedCountDownTime = (timeParserConvertMilliSeconds $countDownTime);

  countDownSeconds = (+ (at $parsedCountDownTime 1) (* (at $parsedCountDownTime 0) 60));
  countDownMilliseconds = (at $parsedCountDownTime 2);

  sleep $countDownMilliseconds [
    showCountDown $countDownSeconds $countDownFinishedMessage;
  ]

]

//
// Counts down a second and displays the seconds remaining.
//
// @param int $arg1 The number of remaining seconds
// @param String $arg2 The message to show when the count down is finished
//
const showCountDown [

  // If last count down change is at least 1000 milliseconds ago or
  // if last count down change is 0 and the count down seconds are equal to the initial number of countdown seconds
  if (&& (isCountDownActive) (|| (&& $lastCountDownChange (>= (- (millis) $lastCountDownChange) 1000)) (&& (! $lastCountDownChange) (= $arg1 $countDownSeconds)))) [

    remainingSeconds = $arg1;
    countDownFinishedMessage = $arg2;

    if (= $remainingSeconds 0) [
      countDownTime = 0;
      echo (c $colorCountDownFinished) $countDownFinishedMessage;
    ][

      echo (concat (getCountDownColor $remainingSeconds) (generateTimeString (* $remainingSeconds 1000) 0));
      lastCountDownChange = (millis);

      sleep 1000 [
        showCountDown (- $remainingSeconds 1) $countDownFinishedMessage;
      ]
    ]

  ]

]

//
// Returns the count down color based on the amount of seconds remaining.
//
// @param int $arg1 The amount of seconds remaining
//
// @return String The count down color
//
const getCountDownColor [

  countDownColor = $colorCountDownDefault;

  if (< $arg1 4)[
    countDownColor = $colorCountDownLessThanFourSecondsRemaining;
  ][
    if (< $arg1 10)[
      countDownColor = $colorCountDownLessThanTenSecondsRemaining;
    ]
  ]

  return (c $countDownColor);

]
