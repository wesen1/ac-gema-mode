//
// @author wesen
// @copyright 2017-2020 wesen <wesen-ac@web.de>
//

exec "scripts/ac-gema-mode/time-target-mode/time-target.cfg";
exec "scripts/ac-gema-mode/time-target-mode/count-down.cfg";
exec "scripts/ac-gema-mode/time-target-mode/time-target-auto-updater.cfg";

//
// Time target module for ac-gema-mode
//
// Provides functions to de-/activate the time target mode.
// Also provides functions to fetch the current time target mode state.
//
// Requires:
//   * scripts/ac-gema-mode/strings.cfg
//   * scripts/ac-gema-mode/map-record/map-record-array.cfg
//   * scripts/ac-gema-mode/map-record/storage/best-map-record-cache.cfg
//   * scripts/ac-gema-mode/map-record/storage/map-record-loader.cfg
//   * scripts/ac-gema-mode/notification-printer.cfg
//   * scripts/ac-gema-mode/score-attempt/current-score-attempt.cfg
//   * scripts/ac-gema-mode/time/time-interval-comparator.cfg
//   * scripts/ac-gema-mode/time-target-mode/count-down.cfg
//   * scripts/ac-gema-mode/time-target-mode/time-target.cfg
//   * scripts/ac-gema-mode/time-target-mode/time-target-auto-updater.cfg
//

// Options

//
// Option to auto reset the time target to 0 on quit (Default: 1)
//
// @var int $optionResetTimeTargetOnQuit
//
check2init optionResetTimeTargetOnQuit 1;

//
// Option to show the difference in minutes to the time target time on score (Default: 1)
//
// @var int $optionShowDifferenceToTimeTarget
//
check2init optionShowDifferenceToTimeTarget 1;


// Global Variables

//
// Stores whether the time target mode is currently active
//
// @var int $timeTargetModeIsActive
//
check2init timeTargetModeIsActive 0;


persistidents 0;

// Public Functions

//
// Sets the time target mode state (Enables/Disables the time target mode).
//
// @param int newTimeTargetModeState ($arg1) The state to which the time target mode will be set
//
// @example `setTimeTargetModeState 1` Activates the time target mode if it can be activated
//
const setTimeTargetModeState [

  newTimeTargetModeState = $arg1;
  timeTargetModeStateCanBeChanged = (!= $timeTargetModeIsActive $newTimeTargetModeState);

  if (&& (= $newTimeTargetModeState 1) (|| $timeTargetModeStateCanBeChanged (! (isTimeTargetModeActive)))) [
    // If the time target mode shall be activated and either:
    //   * The time target mode state can be changed
    //   * The time target mode is not active despite $timeTargetModeIsActive matching the new time target mode state

    timeTargetModeCanNotBeActivatedReason = (getTimeTargetModeCanNotBeActivatedReason);
    if (> (strlen $timeTargetModeCanNotBeActivatedReason) 0) [
      printGemaNotification (format $messageTimeTargetModeCanNotBeActivated $timeTargetModeCanNotBeActivatedReason);
      timeTargetModeStateCanBeChanged = 0;
    ]

  ]

  if ($timeTargetModeStateCanBeChanged) [

    // Update the time target mode state
    timeTargetModeIsActive = $arg1;

    if ($timeTargetModeIsActive) [
      onEnableTimeTargetMode;
    ][
      onDisableTimeTargetMode;
    ]

  ]

]

//
// Returns whether the time target mode is currently active.
//
// @return int 1 if the time target mode is active, 0 otherwise
//
const isTimeTargetModeActive [
  return (&& (isGemaModeActive) $timeTargetModeIsActive);
]


// Private Functions

//
// Returns the reason why the time target mode can not be activated.
//
// @return string The reason or an empty string if the time target mode can be activated
//
const getTimeTargetModeCanNotBeActivatedReason [

  if (! (isGemaModeActive)) [
    return $messageGemaModeNotActive;
  ][
    if (< (getTimeTargetTotalMilliseconds) 0) [
      return $messageInvalidTimeTarget;
    ]
  ]

]

//
// Returns a message that indicates whether the time target was beaten.
//
// @param int scoreTime ($arg1) The score time in milliseconds
//
// @return string The message
//
const getTimeTargetScoreString [

  timeDifference = (- (getTimeTargetTotalMilliseconds) $arg1);

  if (> $timeDifference 0) [

    if (= $optionShowDifferenceToTimeTarget 1) [
      return (format $messageTimeTargetBeatenWithDifference (generateTimeStringFromMilliseconds $timeDifference 1));
    ][
      return $messageTimeTargetBeaten;
    ]

  ][

    if (= $timeDifference 0) [
      // The score time and time target match, no need to show the difference of 0 milliseconds
      return $messageTimeTargetTied;
    ][
      if (= $optionShowDifferenceToTimeTarget 1) [
        timeDifferenceString = (generateTimeStringFromMilliseconds (* $timeDifference -1) 1);
        return (format $messageSlowerThanTimeTargetWithDifference $timeDifferenceString);
      ][
        return $messageSlowerThanTimeTarget;
      ]
    ]
  ]

]

//
// Starts a new count down for the time target.
//
// @param int countDownDuration ($arg1) The count down duration in milliseconds
//
const startCountDown [

  countDownMilliseconds = $arg1;
  if (> $countDownMilliseconds 0) [
    initializeCountDown $countDownMilliseconds $messageTimeTargetFinished;
  ]

]


// Custom Events

//
// Event handler that is called when the time target mode state changes to enabled.
//
checkinit onEnableTimeTargetMode [
]

//
// Event handler that is called when the time target mode state changes to disabled.
//
checkinit onDisableTimeTargetMode [
  setCountDownModeState 0;
]


// Event handlers

//
// Event handler that is called when the time target is changed with "setTimeTarget".
//
checkinit onTimeTargetChange [

  // Abort the running countdown
  if (isCountDownActive) [
    abortCountDown;
  ]

  // Start a new countdown with the remaining time target time
  startCountDown (- (getTimeTargetTotalMilliseconds) (getMillisecondsPassedSinceCurrentScoreAttemptStart));

]

//
// Event handler that is called after the current score attempt was started.
//
checkinit onCurrentScoreAttemptStarted [
  if (isCountDownModeActive) [
    startCountDown (getTimeTargetTotalMilliseconds);
  ]
]

//
// Event handler that is called after the current score attempt was finished.
//
// @param array scoreAttemptMapRecord ($arg1) The map record that was created from the score attempt
//
checkinit onCurrentScoreAttemptFinished [

  if (isTimeTargetModeActive) [

    mapRecord = $arg1;

    if (&& (isCountDownModeActive) (isCountDownActive)) [
      abortCountDown;
    ]

    // Check if the time target matches the score time compare value
    if (= $optionScoreTimeCompareValue 0) [
      compareMapRecord = (getBestMapRecord (curmap));
    ][
      compareMapRecord = (loadWeaponMapRecord (curmap) (getMapRecordWeaponId $mapRecord));
    ]

    // Don't show the score string when the time target matches the score time compare value because
    // the score string and time target string will always show the same information in that case
    if (!= $timeTarget (getMapRecordScoreTime $compareMapRecord)) [
      printGemaNotification (getTimeTargetScoreString (getMapRecordScoreTime $mapRecord));
    ]

  ]

]

//
// Event handler that is called after the current score attempt was aborted.
//
checkinit onCurrentScoreAttemptAborted [
  if (&& (isCountDownModeActive) (isCountDownActive)) [
    abortCountDown;
  ]
]

//
// Event handler that is called when the game is closed.
//
checkinit onQuit [
  if ($optionResetTimeTargetOnQuit) [
    setTimeTarget 0;
  ]
]
