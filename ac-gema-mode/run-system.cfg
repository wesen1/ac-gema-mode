//
// @author wesen
// @copyright 2017-2018 wesen <wesen-ac@web.de>
//

//
// Run system module for ac-gema-mode
//
// Handles the runs/attempts
//
// Requires:
//   * scripts/ac-gema-mode/environment-checker.cfg
//   * scripts/ac-gema-mode/map-name-checker.cfg
//   * scripts/ac-gema-mode/map-record.cfg
//   * scripts/ac-gema-mode/map-record-printer.cfg
//   * scripts/ac-gema-mode/time-target.cfg
//

check2init optionAutoActivateGemaMode 0; // Auto activate gema mode on gema maps

persistidents 0;

check2init startTime 0;  // Start time of the players current run
check2init scoreWeapon -1;  // The weapon that is used during the players current run


////////////////////////////////////////////////////////////////////////////////////
// Custom event handlers
////////////////////////////////////////////////////////////////////////////////////

//
// Detects whether the player changes to edit mode.
//
const checkEditing [

  if ($editing) [
    abortRun;
    printGemaNotification (concat (c $colorRunAborted) "Run aborted because you switched to edit mode!");
  ][
    // continue checking whether player changes to edit mode
    sleep 100 [
      if (isRunActive) [
        checkEditing;
      ]
    ]
  ]

]

//
// Detects whether the player team changes.
//
// @param int $arg1 The initial player team
//
const checkTeam [

  // Must save $arg1 in a variable because $arg1 is cleared before the function invcoation is triggered
  playerTeam = $arg1;

  if (!= (player1 team) $playerTeam) [
    abortRun;
  ][
    sleep 100 [
      if (isRunActive) [
        checkTeam $playerTeam;
      ]
    ]
  ]

]


////////////////////////////////////////////////////////////////////////////////////
// Run system
////////////////////////////////////////////////////////////////////////////////////

//
// Aborts the current run.
//
const abortRun [

  startTime = 0;
  if (&& (isCountDownModeActive) (isCountDownActive)) [
    setCountDownTime 0;
  ]

]

//
// Initializes a new run.
//
const startRun [

  startTime = (millis);

  // Initially set the weapon to "Knife only"
  // When the player uses other weapons the score weapon will be updated
  scoreWeapon = $KNIFE;
  checkTeam (player1 team);
  checkEditing;

  if (isCountDownModeActive) [
    initializeCountDown (getTimeTarget) "Time target finished";
  ]

]

//
// Returns whether a run is active at the moment.
//
const isRunActive [

  if (&& (isGemaModeActive) $startTime) [
    return 1;
  ][
    return 0;
  ]

]


////////////////////////////////////////////////////////////////////////////////////
// Event handlers
////////////////////////////////////////////////////////////////////////////////////

//
// Event handler that is called when a new map starts.
//
checkinit mapstartalways [

  if (&& (isGema) (&& (! (isGemaModeActive)) $optionAutoActivateGemaMode)) [
    setGemaModeActive 1;
    printGemaNotification (concat (c $colorSuccess) "Gema mode automatically activated!");

    if (&& (! (isRunActive)) (player1 alive)) [
      startRun;
    ]
  ]

  if ($gemaModeActive) [

    if (! (isGema)) [
      setGemaModeActive 0;
      printGemaNotification (concat (c $colorGemaModeDeactivated) "Gema mode deactivated: Map is not a gema map or mode is not CTF.");
    ][
      printMapStatistics (curmap);
    ]

  ]

]

//
// Event handler that is called when the intermission is reached (on map end).
//
checkinit start_intermission [
  if (isRunActive) [
    abortRun;
  ]
]

//
// Event handler that is called when player1 attacks.
//
// @param int $arg1 The weapon id of the weapon that was used
//
const onAttack [
  if (isRunActive)[
    scoreWeapon = (updateScoreWeapon $arg1);
  ]
]

//
// Event handler that is called when the player triggers a flag state change.
//
// @param int $arg1 The action that occured
// @param int $arg2 Actor cn
//
checkinit onFlag [

  // If a run is active, player1 is the actor and and the action is "scored"
  if (&& (isRunActive) (&& (= $arg2 (player1 cn)) (= $arg1 4))) [

    newRecordTime = (- (millis) $startTime);
    abortRun;

    printMapRecordScoreString $newRecordTime $scoreWeapon;
    printMapRecordStatusString (curmap) $newRecordTime $scoreWeapon;
    if (&& (isTimeTargetModeActive) (!= (getTimeTarget) (loadMapRecord (curmap)))) [
      showTimeTargetScoreString $newRecordTime;
    ]

    saveMapRecord (curmap) $newRecordTime $scoreWeapon;
  ]

]

//
// Event handler that is called when someone is killed.
//
// @param int $arg1 Actor cn
// @param int $arg2 Target cn
//
checkinit onKill [
  if (&& (isRunActive) (= $arg2 (player1 cn))) [
    abortRun;
  ]
]

//
// Event handler that is called when a player spawns.
//
// @param int $arg1 The cn of the player who spawned
//
checkinit onSpawn [

  // Check whether player is editing. This prevents runs from starting when the player uses /newmap
  if (! $editing) [
    if (&& (isGemaModeActive) (= $arg1 (player1 cn))) [
      startRun;
    ]
  ]

]
