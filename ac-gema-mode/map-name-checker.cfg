//
// @author wesen
// @copyright 2017-2018 wesen <wesen-ac@web.de>
//

//
// Map name checker module for ac-gema-mode
//
// Checks whether a map name is a gema map name
//

persistidents 0;

const gemaMapNameImplicits ["jigsaw" "deadmeat-10"];
const gemaMapNameCodes ["g" "3e" "m" "a@4"];

//
// Stores the last checked map name
//
// @var String $cachedMapName
//
checkinit cachedMapName "";

//
// Stores the result of the isGemaMapName call for the last checked map name to avoid rechecking the same map name over and over
//
// @var int $isCachedMapNameGemaMapName
//
checkinit isCachedMapNameGemaMapName 0;


//
// Returns whether a map name is a gema map name.
//
// @param String $arg1 The map name
//
// @return int 0: Map name is not a gema map name
//             1: Map name is a gema map name
//
const isGemaMapName [

  if (! (strcmp $arg1 $cachedMapName)) [

    cachedMapName = $arg1;
    if (|| (containsGemaMapNameImplicit (tolower $arg1)) (containsGemaMapNameCodes (tolower $arg1))) [
      isCachedMapNameGemaMapName = 1;
    ][
      isCachedMapNameGemaMapName = 0;
    ]
  ]

  return $isCachedMapNameGemaMapName;

]

//
// Checks whether a map name contains one of the implicit words.
//
// @param String $arg1 The map name
//
// @return int 0: Map name does not contain any of the implicit words
//             1: Map name contains one of the implicit words
//
const containsGemaMapNameImplicit [

  mapNameCheckerTmpReturnValue = 0;

  looplist $gemaMapNameImplicits gemaMapNameImplicit [

    if (strstr $arg1 $gemaMapNameImplicit) [
      mapNameCheckerTmpReturnValue = 1;
      break;
    ]

  ]

  return $mapNameCheckerTmpReturnValue;

]

//
// Checks whether a map name contains ge3ma@4.
//
// @param String $arg1 The map name
//
// @return int 0: Map name does not contain ge3ma@4
//             1: Map name contains ge3ma@4
//
const containsGemaMapNameCodes [

  checkMapName = $arg1;
  gemaMapNameCodePosition = 0;
  numberOfGemaMapNameCodes = (listlen $gemaMapNameCodes);

  // Iterate over all letters of the mapname
  parsestring $checkMapName mapNameLetter [

    if (letterMatchesGemaMapNameCode $mapNameLetter $gemaMapNameCodePosition) [
      ++ gemaMapNameCodePosition;
      if (= $gemaMapNameCodePosition $numberOfGemaMapNameCodes) [
        breakparse;
      ]
    ][
      lastGemaMapNameCodePosition = $gemaMapNameCodePosition;
      gemaMapNameCodePosition = 0;

      if (> $lastGemaMapNameCodePosition 0) [
	if (letterMatchesGemaMapNameCode $mapNameLetter 0) [
	  gemaMapNameCodePosition = 1;
        ]
      ]
    ]
  ]

  if (= $gemaMapNameCodePosition $numberOfGemaMapNameCodes) [
    return 1;
  ][
    return 0;
  ]

]

//
// Returns whether a letter matches a specific position of the gema map name code.
//
// @param String $arg1 The letter
// @param int $arg2 The gema map name code position
//
// @return Bool True if the letter matches the map name code position, false otherwise
//
const letterMatchesGemaMapNameCode [

  checkLetter = $arg1;
  gemaMapNameCodePosition = $arg2;

  gemaMapNameCode = (at $gemaMapNameCodes $gemaMapNameCodePosition);
  matchesGemaMapNameCode = 0;

  // Must use loop here because nested parsestrings do not work
  loop i (strlen $gemaMapNameCode) [

    gemaMapNameCodeLetter = (substr $gemaMapNameCode $i 1);
    if (strcmp $gemaMapNameCodeLetter $checkLetter) [
      matchesGemaMapNameCode = 1;
      break;
    ]

  ]

  return $matchesGemaMapNameCode;
]
