//
// @author wesen
// @copyright 2020 wesen <wesen-ac@web.de>
//

//
// Format string parser module for ac-gema-mode
//
// Provides functions to parse format specifier rules from format strings.
// Format specifiers start with a "%" and end with arbitrary symbols, they may also include
// symbols between the "%" and the end symbol and after the end symbol.
//

persistidents 0;


const timeFormatSpecifierEndCharacters [i s v T %];


const parseFormatString [

  targetFormatString = $arg1;

  if (= $numargs 1) [
    cycleNumber = 0;
  ][
    cycleNumber = $arg2;
  ]

  // Find and parse the next format specifier
  nextFormatSpecifierStartPosition = (strpos $targetFormatString "%" $cycleNumber);
  if (!= $nextFormatSpecifierStartPosition -1) [
    // Found a next format specifier
    parseNextFormatSpecifier $targetFormatString $nextFormatSpecifierStartPosition;
    parseTimeFormatString $targetFormatString (+ $cycleNumber 1);
  ]

  targetFormatString = (strreplace $targetFormatString \ ""); // TODO: Does not replace \\ by \

  return (trimLeadingAndTrailingWhitespace $targetFormatString);

]

const parseNextFormatSpecifier [

  characterBeforeFormatSpecifier = (substr $arg1 (- $arg2 1) 1);

  if (! (strcmp $characterBeforeFormatSpecifier \)) [
    // The "%" at the start is not escaped by a backslash (it's not "\%")

    formatSpecifierStartPosition = (+ $arg2 1);
    remainingTimeFormatString = (substr $arg1 $formatSpecifierStartPosition);

    // Find the closest format specifier type
    closestFormatSpecifierEndCharacter = "";
    closestFormatSpecifierEndCharacterPosition = -1;
    looplist $timeFormatSpecifierEndCharacters formatSpecifierEndCharacter [

      formatSpecifierEndCharacterPosition = (strpos $remainingTimeFormatString $formatSpecifierEndCharacter);
      if (&& (!= $formatSpecifierEndCharacterPosition -1) (|| (= $closestFormatSpecifierEndCharacterPosition -1) (> $closestFormatSpecifierEndCharacterPosition $formatSpecifierEndCharacterPosition))) [
        closestFormatSpecifierEndCharacter = $formatSpecifierEndCharacter;
        closestFormatSpecifierEndCharacterPosition = $formatSpecifierEndCharacterPosition;
      ]
    ]

    if (&& (!= $closestFormatSpecifierEndCharacterPosition -1) (! (strcmp $closestFormatSpecifierEndCharacter "%"))) [
      // Found a end character for the format specifier and it was not the start of another format specifier

      characterAfterFormatSpecifier = (substr $remainingTimeFormatString (+ $closestFormatSpecifierEndCharacterPosition 1) 1);
      if (strstr "+-" $characterAfterFormatSpecifier) [
        formatSpecifierEndPosition = (+ $closestFormatSpecifierEndCharacterPosition 1);
      ][
        formatSpecifierEndPosition = $closestFormatSpecifierEndCharacterPosition;
      ]

      formatSpecifierString = (concatword "%" (substr $remainingTimeFormatString 0 (+ $formatSpecifierEndPosition 1)));

      if (! (formatSpecifierRuleExists $formatSpecifierString)) [
        // New unique format specifier found

        formatSpecifierType = $closestFormatSpecifierEndCharacter;

        if (strcmp $characterAfterFormatSpecifier "-") [
          // Abbreviated time units
          timeUnitType = 1;
        ][
          if (strcmp $characterAfterFormatSpecifier "+") [
            // Full time units
            timeUnitType = 2;
          ][
            // No time unit
            timeUnitType = 0;
          ]
        ]

        if (= $closestFormatSpecifierEndCharacterPosition 0) [
          numberOfZeroPaddingDigits = 0;
        ][
          numberOfZeroPaddingDigits = (substr $remainingTimeFormatString 0 $closestFormatSpecifierEndCharacterPosition);
        ]

        formatSpecifierRule = (concat $formatSpecifierString $formatSpecifierType $timeUnitType $numberOfZeroPaddingDigits );
        lastFoundFormatSpecifierRules = (array_append $lastFoundFormatSpecifierRules $formatSpecifierRule 2);
      ]

    ]

  ]

]


const formatSpecifierRuleExists [

  ruleWithSameFormatSpecifierStringFound = 0;
  loop i (array_length $lastFoundFormatSpecifierRules "  ") [
    formatSpecifierRule = (array_get $lastFoundFormatSpecifierRules $i 2);

    if (strcmp (at $formatSpecifierRule 0) $arg1) [
      ruleWithSameFormatSpecifierStringFound = 1;
      break;
    ]
  ]

  return $ruleWithSameFormatSpecifierStringFound;

]
