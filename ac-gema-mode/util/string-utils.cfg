//
// @author wesen
// @copyright 2018-2020 wesen <wesen-ac@web.de>
//

//
// String utils module for ac-gema-mode
//
// Provides various string util functions.
//

persistidents 0;


// Public Functions

//
// Replaces a part of a string with a sub string and returns the result.
//
// @param string targetString ($arg1) The target string
// @param string replacement ($arg2) The replacement string
// @param int startPosition ($arg3) The start position
// @param int endPosition ($arg4) The end position (optional)
//
// @return string The modified string
//
// @example `substr_replace hello world 2` Returns "heworld"
// @example `substr_replace hello universe 0 1` Returns "universello"
//
const substr_replace [

  if (|| (< $numargs 3) (strcmp $arg1 "")) [
    return $arg1;
  ][

    substrreplace_initialString = $arg1;
    substrreplace_replacementString = $arg2;
    substrreplace_startPosition = $arg3;

    substrreplace_initialStringLength = (strlen $substrreplace_initialString);

    // Calculate end position
    if (> $numargs 3) [
      substrreplace_endPosition = $arg4;
      if (< $arg4 0) [
        substrreplace_endPosition = (+ $substrreplace_initialStringLength $substrreplace_endPosition);
      ]
    ][
      substrreplace_endPosition = $substrreplace_initialStringLength;
    ]

    if (<= $substrreplace_startPosition $substrreplace_endPosition) [

      // Extract the part left from the part that will be replaced
      if (<= $substrreplace_startPosition 0) [
        substrreplace_leftPart = "";
      ][
        substrreplace_leftPart = (substr $substrreplace_initialString 0 $substrreplace_startPosition);
      ]

      // Extract the part right from the part that will be replaced
      if (>= $substrreplace_endPosition $substrreplace_initialStringLength) [
        substrreplace_rightPart = "";
      ][
        substrreplace_rightPart = (substr $substrreplace_initialString (+ $substrreplace_endPosition 1));
      ]

      // Glue together the left part, the replacement and the right part
      return (concatword $substrreplace_leftPart $substrreplace_replacementString $substrreplace_rightPart);

    ][
      return $substrreplace_initialString;
    ]

  ]

]

//
// Returns a string repeated a specified number of times.
//
// @param string repeatString ($arg1) The string that will be repeated
// @param int numberOfRepetitions ($arg2) The number of repetitions
//
// @return string The repeated string
//
// @example `strrepeat x 5` Returns "xxxxx"
//
const strrepeat [

  if (< $numargs 2) [
    return $arg1;
  ][

    strrepeat_repeatString = $arg1;
    strrepeat_numberOfRepeats = $arg2;

    strrepeat_resultString = "";
    loop strrepeat_i $strrepeat_numberOfRepeats [
      strrepeat_resultString = (concatword $strrepeat_resultString $strrepeat_repeatString);
    ]

    return $strrepeat_resultString;

  ]

]

//
// Counts and returns the number of occurrences of a substring inside a string.
//
// @param string haystack ($arg1) The haystack
// @param string needle ($arg2) The needle
//
// @return int The number of occurrences
//
// @example `substr_count "hello world" l` Returns 3
//
const substr_count [

  if (|| (< $numargs 2) (strcmp $arg2 "")) [
    return -1;
  ][

    substrcount_haystack = $arg1;
    substrcount_needle = $arg2;
    substrcount_needleLength = (strlen $substrcount_needle);

    substrcount_needlePosition = (strpos $substrcount_haystack $substrcount_needle);
    if (!= $substrcount_needlePosition -1) [
      substrcount_remainingString = (substr $substrcount_haystack (+ $substrcount_needlePosition $substrcount_needleLength));
      return (+ 1 (substr_count $substrcount_remainingString $substrcount_needle));

    ][
      return 0;
    ]

  ]

]

//
// Checks if a string contains at least one needle of a list of needles.
//
// @param string haystack ($arg1) The string that will be searched (haystack)
// @param string[] needles ($arg2) The strings to search for (needles)
//
// @return int 1 if the string contains at least one of the needles, 0 otherwise
//
// @example `strstr_array "hello" "k l m"` Returns 1 because "hello" contains "l"
// @example `strstr_array "gema" "v w x y z"` Returns 0 because "gema" does not contain "v", "w", "x", "y" or "z"
//
const strstr_array [

  if (|| (< $numargs 2) (strcmp $arg2 "")) [
    return -1;
  ][

    searchString = $arg1;
    needles = $arg2;

    searchStringContainsNeedle = 0;
    looplist $needles needle [
      if (strstr $searchString $needle) [
        searchStringContainsNeedle = 1;
        break;
      ]
    ]

    return $searchStringContainsNeedle;

  ]

]

//
// Converts the first character of a string to uppercase and returns the modified string.
//
// @param string targetString ($arg1) The target string
//
// @return string The modified string
//
const uppercase_first [
  targetString = $arg1;
  return (concatword (toupper (substr $targetString 0 1)) (substr $targetString 1));
]

//
// Removes leading and trailing whitespace from a given string.
//
// @param string targetString ($arg1) The target string
//
// @return string The string with removed leading and trailing whitespace
//
const trimLeadingAndTrailingWhitespace [

  targetString = $arg1;

  // Cannot use testchar here because the special string that is added via (c <color) is detected as whitespace
  // and removing it breaks the color
  subStringStartPosition = 0;
  parsestring $targetString targetStringCharacter [
    if (strcmp $targetStringCharacter " ") [
      ++ subStringStartPosition;
    ][
      breakparse;
    ]
  ]

  subStringLength = (- (strlen $targetString) $subStringStartPosition);
  parsestring $targetString targetStringCharacter [
    if (strcmp $targetStringCharacter " ") [
      -- subStringLength;
    ][
      breakparse;
    ]
  ] 1;

  return (substr $targetString $subStringStartPosition $subStringLength);

]

//
// Finds and returns the first strpos result that is not preceded by a given string.
//
// @param string targetString ($arg1) The target string
// @param string needle ($arg2) The needle to search for
// @param string forbiddenPrecedingSubstring ($arg3) The substring that may not preced the needle
// @param int occurrenceNumber ($arg4) The strpos occurrence number to check (optional) (Used for recursion)
//
// @return int The first strpos result that is not preceded by the forbidden substring
//
const findStrPosWithoutPrecedingSubstring [

  targetString = $arg1;
  needle = $arg2;
  forbiddenPrecedingSubstring = $arg3;

  if (= $numargs 4) [
    occurrenceNumber = $arg4;
  ][
    occurrenceNumber = 0;
  ]

  needlePosition = (strpos $targetString $needle $occurrenceNumber);
  isValidResult = 1;
  if (> $needlePosition 0) [
    forbiddenPrecedingSubstringLength = (strlen $forbiddenPrecedingSubstring);
    precedingSubstring = (substr $targetString (- $needlePosition $forbiddenPrecedingSubstringLength) $forbiddenPrecedingSubstringLength);

    isValidResult = (! (strcmp $precedingSubstring $forbiddenPrecedingSubstring));
  ]

  if ($isValidResult) [
    return $needlePosition;
  ][
    return (findStrPosWithoutPrecedingSubstring $targetString $needle $forbiddenPrecedingSubstring (+ $occurrenceNumber 1));
  ]

]
